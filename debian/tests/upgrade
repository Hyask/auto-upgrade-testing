#!/bin/bash

TMP_LOCATION="/tmp/ubuntu-upgrade-testing"
BASE_LOCATION="${ADT_ARTIFACTS}/upgrade_run_config"
PRE_SCRIPT_LOCATION="${BASE_LOCATION}/pre_scripts"
POST_SCRIPT_LOCATION="${BASE_LOCATION}/post_scripts"
# Currently experimenting with using yaml output for run results (test
# pass/fail etc.) for now, then we'll use something better
TEST_RESULTS_DIR="${ADT_ARTIFACTS}/upgrade_run"
TEST_RESULT_FILE="${TEST_RESULTS_DIR}/runner_results.yaml"
CANARY_NAME="/tmp/upgrade_script_reboot_canary"

# Only copy on the first run through
if [ ! -d "${BASE_LOCATION}" ]; then
   mkdir "${BASE_LOCATION}"
   mv "${TMP_LOCATION}/pre_scripts" "${BASE_LOCATION}"
   mv "${TMP_LOCATION}/post_scripts" "${BASE_LOCATION}"
   mv "${TMP_LOCATION}/auto_upgrade_test_settings" "${BASE_LOCATION}"
fi

# This is put in a known place by the wrapper script and contains the details
# of above (as they will change each run).
CONFIG_FILE="${BASE_LOCATION}/auto_upgrade_test_settings"
source "${CONFIG_FILE}"
export TEST_RESULTS_DIR

HAVE_REBOOTED=$ADT_REBOOT_MARK

STATUS=0

function upgrade_log() {
    local output=$1
    echo -e "auto-upgrade [$(date +%R:%S)]: ${output}"
}

function cleanup() {
    cp "${CONFIG_FILE}" "${TEST_RESULTS_DIR}"
    upgrade_log "Cleaning up configuration files."
    rm -r "${BASE_LOCATION}"
}

function main() {
    # Ensure we don't have any mix-ups with multiple runs on the same testbed.
    trap cleanup EXIT

    upgrade_log "Running on ${RUNNING_BACKEND}"

    if [ -z "${HAVE_REBOOTED}" ]; then
        upgrade_log "Beginning from the start."
        create_reboot_canary

        # Haven't rebooted, starting from the beginning.
        output_running_system

        do_setup

        exit_if_not_running_initial_system

        pre_tests

        do_upgrade_and_maybe_reboot
    else
        upgrade_log "Skipping pre-tests as we have rebooted."
    fi

    # If we have rebooted we pick up from here.
    output_running_system
    exit_if_reboot_canary_exists
    exit_if_not_running_expected_post_system

    post_tests

    collect_results

    exit $STATUS
}

function exit_if_not_running_initial_system() {
    local running_system=$(_get_running_system_name)
    upgrade_log "Checking that running system (${running_system}) is ${INITIAL_SYSTEM_STATE}"
    if [ "${INITIAL_SYSTEM_STATE}" != "${running_system}" ]; then
        upgrade_log "ERROR: Expected ${INITIAL_SYSTEM_STATE} got ${running_system}"
        # Is there a better way than just exiting here?
        exit 1
    fi
}

# Can we de-dupe these methods too?
function exit_if_not_running_expected_post_system() {
    local running_system=$(_get_running_system_name)
    upgrade_log "Checking that running system (${running_system}) is ${POST_SYSTEM_STATE}"
    if [ "${POST_SYSTEM_STATE}" != "${running_system}" ]; then
        upgrade_log "ERROR: Expected ${POST_SYSTEM_STATE} got ${running_system}"
        # Is there a better way than just exiting here?
        exit 1
    fi
}

function create_reboot_canary() {
    touch "${CANARY_NAME}"
}

function exit_if_reboot_canary_exists() {
    if [ -f "${CANARY_NAME}" ]; then
        upgrade_log "ERROR: system has not rebooted"
        exit 1
    fi
}

function _get_running_system_name() {
    if running_on_touch_device; then
        local image_detail=$(system-image-cli -i)
        local revno=$(echo "${image_detail}" | awk '/version\ version:/ {print $3}')
        local channel=$(echo "${image_detail}" | awk '/channel:/ {print $2}')
        echo "${channel}:${revno}"
    else
        echo $(lsb_release -c | sed -e "s/\bCodename:\s*\(\w*\)/\1/")
    fi
}

function pre_tests() {
    # Script setup and run. For each test:
    #  - create a output dir for the results and make available to script
    #  - Run script
    #  - Log success or failure of script
    echo "pre_script_output:" >> ${TEST_RESULT_FILE}
    for test in $PRE_TESTS_TO_RUN; do

        local this_script_results="${TEST_RESULTS_DIR}/pre_${test}/"
        mkdir "${this_script_results}"
        export TESTRUN_RESULTS_DIR=$this_script_results

        local FULL_TEST_SCRIPT_PATH="${PRE_SCRIPT_LOCATION}/${test}"
        upgrade_log "Running test: ${FULL_TEST_SCRIPT_PATH} -- Results: ${this_script_results}"
        ${FULL_TEST_SCRIPT_PATH}

        local test_result=$?
        if (( test_result != 0 )); then
            echo "  \"${test}\": FAIL" >> ${TEST_RESULT_FILE}
        else
            echo "  \"${test}\": PASS" >> ${TEST_RESULT_FILE}
        fi
    done
}

function post_tests() {
    # Script setup and run. For each test:
    #  - create a output dir for the results and make available to script
    #  - Run script
    #  - Log success or failure of script
    echo "post_test_output:" >> $TEST_RESULT_FILE
    for test in $POST_TESTS_TO_RUN; do
        local this_script_results="${TEST_RESULTS_DIR}/post_${test}/"
        mkdir "${this_script_results}"
        export TESTRUN_RESULTS_DIR=$this_script_results

        local FULL_TEST_SCRIPT_PATH="${POST_SCRIPT_LOCATION}/${test}"
        upgrade_log "Running test: ${FULL_TEST_SCRIPT_PATH} -- Results: ${this_script_results}"

        ${FULL_TEST_SCRIPT_PATH}

        local test_result=$?
        if (( test_result != 0 )); then
            echo "  \"${test}\": FAIL" >> $TEST_RESULT_FILE
        else
            echo "  \"${test}\": PASS" >> $TEST_RESULT_FILE
        fi
    done
}

function do_setup() {
    upgrade_log "Performing run setup."
    # Make sure the output results file is available and proper yaml.
    mkdir "${TEST_RESULTS_DIR}"
    echo "---" >> "${TEST_RESULT_FILE}"
}

function do_upgrade_and_maybe_reboot() {
    current="${INITIAL_SYSTEM_STATE}"
    target="${POST_SYSTEM_STATE}"
    upgrade_log "Attempting to upgrade from ${current} to ${target}"

    if running_on_touch_device; then
        do_touch_device_upgrade
    else
        do_normal_upgrade
        maybe_reboot
    fi

    if [ $STATUS -ne 0 ]; then
        upgrade_log "Something went wrong with the upgrade."
        exit 1
    fi

    upgrade_log "Upgrading complete."
}

function do_touch_device_upgrade() {
    upgrade_log "Starting device upgrade."
    local channel=`expr "${POST_SYSTEM_STATE}" : '\(^.*\):'`
    local revision=`expr "${POST_SYSTEM_STATE}" : '^.*:\([0-9]*\)$'`
    upgrade_log "Upgrading to: channel: ${channel} revno: ${revision}"

    # Do both so we have some history of the logs as well as save time after
    # the reboot prepare (which will just start the run again after a while.)
    # TODO: Determine if possible to change this behaviour.
    upgrade_log "Downloading details with: system-image-cli -v --no-reboot --channel ${channel} --build ${revision}"
    system-image-cli -v --no-reboot --channel "${channel}" --build "${revision}"
    upgrade_log "Now actually doing install now which will reboot the device."
    # Don't output/log anything after reboot_prepare as it stops us being able to reboot the device.
    reboot_prepare
    system-image-cli -v --channel "${channel}" --build "${revision}" &>> /home/phablet/veebers-reboot.log
    STATUS=$?
}

function reboot_prepare() {
    prepare_function="/tmp/autopkgtest-reboot-prepare"
    if [ -f ${prepare_function} ]; then
        upgrade_log "Preparing the system for reboot."
        $($prepare_function 'upgradetests')
        sleep 30
    else
        upgrade_log "This testbed does not support rebooting."
        exit 1
    fi
}

function do_normal_upgrade() {
    upgrade_log "Starting machine upgrade."
    # copy the profile
    mkdir -p /etc/update-manager/release-upgrades.d
    # copy from outside self.profile /etc/update-manager/release-upgrades.d

    # check overrides
    # *unimplemented

    # set test repo
    # if it exists, do unimplemented things

    # if apt_conf, then copy in /etc/apt/apt.conf.d

    # setup debconf logging?
    # check on forceoverride and noninteractive

    # if we have an upgradefilesidr, use it
    if (false) ; then # derp
        upgrade_log "using the upgradefilesdir!" # herp
    else
        export DEBIAN_FRONTEND=noninteractive
	    # Make sure we have do-release-upgrade
        apt-get update
        apt-get -y --force-yes install openssh-server update-manager-core
        do-release-upgrade -d -f DistUpgradeViewNonInteractive
        #    do-release-upgrade -d -f noninteractive
        STATUS=$?
    fi
}

function maybe_reboot() {
    # Check if we actually want to reboot . . .
    reboot_function="/tmp/autopkgtest-reboot"
    if [ -f ${reboot_function} ]; then
        upgrade_log "Rebooting the system."
        if [ "${RUNNING_BACKEND}" = "lxc" ]; then
            # lxc reboot is doing something different to expected.
            rm "${CANARY_NAME}"
        fi
        $($reboot_function 'upgradetests')
    else
        upgrade_log "This testbed does not support rebooting."
        exit 1
    fi
}

function collect_results() {
    # Move any files of interest into $TEST_RESULT_DIR
    upgrade_log "Collecting results"
    # get /var/log/dist-upgrade/*
    # get /var/log/dpkg.log
}


function running_on_touch_device() {
    TRUE=0
    FALSE=1
    # RUNNING_BACKEND is supplied by the configuration file.
    if [ "${RUNNING_BACKEND}" = "touch" ]; then
        return $TRUE
    else
        return $FALSE
    fi
}

function output_running_system() {
    if running_on_touch_device; then
        # Return a string like: {channel}:{rev}
        local image_detail=$(system-image-cli -i)
        local revno=$(echo "${image_detail}" | awk '/version\ version:/ {print $3}')
        local channel=$(echo "${image_detail}" | awk '/channel:/ {print $2}')
        echo "${channel}:${revno}"
    else
        echo "Currently running: $(lsb_release -a)"
    fi
}

main "$@"
