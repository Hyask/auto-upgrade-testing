#!/bin/bash

BASE_LOCATION="/tmp/ubuntu-upgrade-testing"
SCRIPT_LOCATION="${BASE_LOCATION}/run_scripts"
# Currently experimenting with using yaml output for run results (test
# pass/fail etc.) for now, then we'll use something better
TEST_RESULTS_DIR="${ADT_ARTIFACTS}/upgrade_run"
TEST_RESULT_FILE="${TEST_RESULTS_DIR}/runner_results.yaml"

# This is put in a known place by the wrapper script and contains the details
# of above (as they will change each run.
CONFIG_FILE="${BASE_LOCATION}/auto_upgrade_test_settings"
source "${CONFIG_FILE}"
export TEST_RESULTS_DIR

HAVE_REBOOTED=$ADT_REBOOT_MARK

STATUS=0

function cleanup() {
    echo -e "Cleaning up configuration files."
    rm -r "${BASE_LOCATION}"
}

function main() {
    # Ensure we don't have any mix-ups with multiple runs on the same testbed.
    trap cleanup EXIT

    if [ -z "${HAVE_REBOOTED}" ]; then
        echo -e "Beginning from the start."
        # Haven't rebooted, starting from the beginning.
        output_running_system

        do_setup

        exit_if_not_running_initial_system

        pre_tests

        do_upgrade

        maybe_reboot
    else
        echo -e "Skipping pre-tests as we have rebooted."
    fi

    # If we have rebooted we pick up from here.
    output_running_system
    # exit_if_not_running_post_system

    post_tests

    collect_results

    exit $STATUS
}

function exit_if_not_running_initial_system() {
    # This needs to branch if this is a lxc or device run.
    local running_system=$(_get_running_system_name)
    echo "Checking that running system (${running_system}) is ${INITIAL_SYSTEM_STATE}"
    if [ "${INITIAL_SYSTEM_STATE}" != "${running_system}" ]; then
        echo "ERROR: Expected ${INITIAL_SYSTEM_STATE} got ${running_system}"
        # Is there a better way than just exiting here?
        exit 1
    fi
}

# Can we de-dupe these methods too?
function exit_if_not_running_post_system() {
    # This needs to branch if this is a lxc or device run.
    local running_system=$(_get_running_system_name)
    echo "Checking that running system (${running_system}) is ${POST_SYSTEM_STATE}"
    if [ "${POST_SYSTEM_STATE}" != "${running_system}" ]; then
        echo "ERROR: Expected ${POST_SYSTEM_STATE} got ${running_system}"
        # Is there a better way than just exiting here?
        exit 1
    fi
}

function _get_running_system_name() {
    local release=$(lsb_release -c | sed -e "s/\bCodename:\s*\(\w*\)/\1/")
    echo "${release}"
}

function pre_tests() {
    # Script setup and run. For each test:
    #  - create a output dir for the results and make available to script
    #  - Run script
    #  - Log success or failure of script
    echo "pre_script_output:" >> ${TEST_RESULT_FILE}
    for test in $PRE_TESTS_TO_RUN; do

        local this_script_results="${TEST_RESULTS_DIR}/pre_${test}/"
        mkdir "${this_script_results}"
        export TESTRUN_RESULTS_DIR=$this_script_results

        local FULL_TEST_SCRIPT_PATH="${SCRIPT_LOCATION}/${test}"
        echo -e "Running test: ${FULL_TEST_SCRIPT_PATH} -- Results: ${this_script_results}"
        ${FULL_TEST_SCRIPT_PATH}

        local test_result=$?
        if (( test_result != 0 )); then
            echo "  \"${test}\": FAIL" >> ${TEST_RESULT_FILE}
        else
            echo "  \"${test}\": PASS" >> ${TEST_RESULT_FILE}
        fi
    done
}

function post_tests() {
    # Script setup and run. For each test:
    #  - create a output dir for the results and make available to script
    #  - Run script
    #  - Log success or failure of script
    echo "post_test_output:" >> $TEST_RESULT_FILE
    for test in $POST_TESTS_TO_RUN; do
        local this_script_results="${TEST_RESULTS_DIR}/post_${test}/"
        mkdir "${this_script_results}"
        export TESTRUN_RESULTS_DIR=$this_script_results

        local FULL_TEST_SCRIPT_PATH="${SCRIPT_LOCATION}/${test}"
        echo -e "Running test: ${FULL_TEST_SCRIPT_PATH} -- Results: ${this_script_results}"

        ${FULL_TEST_SCRIPT_PATH}

        local test_result=$?
        if (( test_result != 0 )); then
            echo "  \"${test}\": FAIL" >> $TEST_RESULT_FILE
        else
            echo "  \"${test}\": PASS" >> $TEST_RESULT_FILE
        fi
    done
}

function do_setup() {
    echo -e "Performing run setup."
    # Make sure the file is available and proper yaml.
    mkdir "${TEST_RESULTS_DIR}"
    echo "---" >> "${TEST_RESULT_FILE}"
}

function do_upgrade() {
    current='P'
    target='T'
    echo -e "Attempting to upgrade from ${current} to ${target}"
    # Do something different if this is a device etc.

    # copy the profile
    mkdir -p /etc/update-manager/release-upgrades.d
    # copy from outside self.profile /etc/update-manager/release-upgrades.d

    # check overrides
    # *unimplemented

    # set test repo
    # if it exists, do unimplemented things

    # if apt_conf, then copy in /etc/apt/apt.conf.d

    # setup debconf logging?
    # check on forceoverride and noninteractive

    # if we have an upgradefilesidr, use it
    if (false) ; then # derp
        echo "using the upgradefilesdir!" # herp
    else
        export DEBIAN_FRONTEND=noninteractive
	    # Make sure we have do-release-upgrade
        apt-get -y --force-yes install openssh-server update-manager-core
        do-release-upgrade -d -f DistUpgradeViewNonInteractive
        #    do-release-upgrade -d -f noninteractive
        STATUS=$?
    fi
    echo -e "Upgrading complete."
}

function maybe_reboot() {
    # Check if we actually want to reboot . . .
    reboot_function="/tmp/autopkgtest-reboot"
    if [ -f ${reboot_function} ]; then
        echo -e "Rebooting the system."
        $($reboot_function 'upgradetests')
    else
        echo -e "This testbed does not support rebooting."
    fi
}

function collect_results() {
    # Move any files of interest into $TEST_RESULT_DIR
    echo -e "Collecting results"
    # get /var/log/dist-upgrade/*
    # get /var/log/dpkg.log
}

function output_running_system() {
    echo -e "Currently running: $(lsb_release -a)"
}

main "$@"
