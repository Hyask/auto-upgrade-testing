#!/bin/bash

SCRIPT_LOCATION='/root/run_scripts/'
# Currently experimenting with using yaml output for run results (test
# pass/fail etc.) for now, then we'll use something better
TEST_RESULTS_DIR="${ADT_ARTIFACTS}/upgrade_run"
TEST_RESULT_FILE="${TEST_RESULTS_DIR}/runner_results.yaml"

# This is put in a known place by the wrapper script and contains the details
# of above (as they will change each run.
source /root/auto_upgrade_test_settings

HAVE_REBOOTED=$ADT_REBOOT_MARK

STATUS=0

function main() {
    if [ -z "${HAVE_REBOOTED}" ]; then
        echo -e "Beginning from the start."
        # Haven't rebooted, starting from the beginning.
        output_running_system

        do_setup

        pre_tests

        # do_upgrade

        maybe_reboot
    else
        echo -e "Skipping pre-tests as we have rebooted."
    fi

    # If we have rebooted we pick up from here.
    output_running_system

    post_tests

    collect_results

    exit $STATUS
}

function pre_tests() {
    # Script setup and run. For each test:
    #  - create a output dir for the results and make available to script
    #  - Run script
    #  - Log success or failure of script
    echo "pre_script_output:" >> ${TEST_RESULT_FILE}
    for test in $PRE_TESTS_TO_RUN; do

        this_script_results="${TEST_RESULTS_DIR}/pre_${test}/"
        mkdir "${this_script_results}"
        export TESTRUN_RESULTS_DIR=$this_script_results

        FULL_TEST_SCRIPT_PATH="${SCRIPT_LOCATION}/${test}"
        echo -e "Running test: ${FULL_TEST_SCRIPT_PATH} -- Results: ${this_script_results}"
        ${FULL_TEST_SCRIPT_PATH}

        test_result=$?
        if (( test_result != 0 )); then
            echo "  \"${test}\": FAIL" >> ${TEST_RESULT_FILE}
        else
            echo "  \"${test}\": PASS" >> ${TEST_RESULT_FILE}
        fi
    done
}

function post_tests() {
    echo "post_test_output:" >> $TEST_RESULT_FILE
    for test in $POST_TESTS_TO_RUN; do
        FULL_TEST_SCRIPT_PATH="${SCRIPT_LOCATION}/${test}"
        echo -e "Running test: ${FULL_TEST_SCRIPT_PATH}"

        # Actually run the script
        ${FULL_TEST_SCRIPT_PATH}

        test_result=$?
        if (( test_result != 0 )); then
            echo "  \"${test}\": FAIL" >> $TEST_RESULT_FILE
        else
            echo "  \"${test}\": PASS" >> $TEST_RESULT_FILE
        fi
        # Collecting the results of course.
    done
}

function do_setup() {
    echo -e "Performing run setup."
    # Make sure the file is proper yaml.
    mkdir "${TEST_RESULTS_DIR}"
    echo "---" >> "${TEST_RESULT_FILE}"
}

function do_upgrade() {
    echo -e "Attempting to upgrade."
    # Probably do something different if this is a device etc.

    # copy the profile
    mkdir -p /etc/update-manager/release-upgrades.d
    # copy from outside self.profile /etc/update-manager/release-upgrades.d

    # check overrides
    # *unimplemented

    # set test repo
    # if it exists, do unimplemented things

    # if apt_conf, then copy in /etc/apt/apt.conf.d

    # setup debconf logging?
    # check on forceoverride and noninteractive

    # if we have an upgradefilesidr, use it
    if (false) ; then # derp
        echo "using the upgradefilesdir!" # herp
    else
        export DEBIAN_FRONTEND=noninteractive
	    # Make sure we have do-release-upgrade
        apt-get -y --force-yes install openssh-server update-manager-core
        do-release-upgrade -d -f DistUpgradeViewNonInteractive
        #    do-release-upgrade -d -f noninteractive
        STATUS=$?
    fi
    echo -e "Upgrading complete."
}

function maybe_reboot() {
    # Check if we actually want to reboot . . .
    reboot_function="/tmp/autopkgtest-reboot"
    if [ -f ${reboot_function} ]; then
        echo -e "Rebooting the system."
        $($reboot_function 'upgradetests')
    else
        echo -e "This testbed does not support rebooting."
    fi
}

function collect_results() {
    # Move any files of interest into $TEST_RESULT_DIR
    echo -e "Collecting results"
    # get /var/log/dist-upgrade/*
    # get /var/log/dpkg.log
}

function output_running_system() {
    echo -e "Currently running: $(lsb_release -a)"
}

main "$@"
